---
layout : single
title: "정리"
excerpt : " "
categories :
- Java
tags :
- [Java]
toc: true #Table of contents 옆에 목록이 생성됨
toc_sticky: true #toc가 화면을 따라 내려옴
toc_label: 목차 #toc 상단에 써있는 제목

date: 2022-08-05
last_modified_at: 2022-08-05
---

## 클래스, 객체, 인스턴스

클래스, 객체, 인스턴스의 개념 및 차이

### 개념

#### 클래스(Class)

- 객체를 만들어 내기 위한 설계도 또는 툴
- 연관되어 있는 변수와 메서드의 집합

#### 객체(Object)

- 소프트웨어 세계에 구현할 대상
- 클래스에 선언된 모양 그대로 생성된 실체

- '클래스의 인스턴스'라고도 부른다.
- 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
- OOP 관점에서 클래스 타입으로 선언되었을 때 '객체'라고 부른다.

#### 인스턴스(Instance)

- 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
  - 객체를 소포트웨어에 실체화 하면 그것을 인스턴스라고 부른다
  - 실체화된 인스턴스는 메모링 ㅔ할당된다

- 인스턴스는 객체에 포함된다고 볼 수 있다.
- OOP의 관점에서 객체가 메모리에 할당되어 실제 사용할 때 인스턴스라고 부른다.

#### 예시

```
/* 클래스 */
public class Animal{
  ...
}

/* 객체와 인스턴스 */
public class Main{
  public static void main(String[] args){
    Animal cat, dog; // 객체

    // 인스턴스화
    // Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
    cat = new Animal();
    dog = new Animal();
  }
}
```


### 차이

#### 클래스 VS 객체

- 클래스는 설계도, 객체는 설계도로 구현한 모든 대상을 의미한다.

#### 객체 VS 인스턴스

- 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
- 객체는 실체, 인스턴스는 관계에 초점을 맞춘다.



## var, let, const, 호이스팅

### var

- 함수레벨 스코프틑 가지고 있다.
- var 키워드 생략 가능하다.
- 중복 선언이 가능하다.

### let

- 블록 수준 스코프를 가지고 있다.
- 중복선언이 불가능하다.

### const

- 블록 수준 스코프를 가지고 있다.
- 초기화와 동시에 선언이 이루어져야 한다.
- 불변하는 값이다.

### 호이스팅(Hoisting)

- 함수 내부에 있는 선언들을 모두 끌어올려 해당 함수 유효 범위의 최상단에 선언하는 것을 뜻함.
- var : 호이스팅이 발생함
  - 변수가 선언되기 전에 참조되어도 에러가 발생하지 않는다.
  - 내부에서 미리 변수를 선언하고 `undefined` 로 초기화를 해둔다.

- let, const : 호이스팅이 약간 다른방식으로 작동됨
  - 변수가 선언되기 전에 참조하면 에러가 발생한다.
  - 선언은 되어있지만 초기화는 변수 선언문을 만났을 때 수행하게된다.
  - 위의 에러가 발생하는 구간을 TDZ(Temporal Dead Zone)이라고 한다.


## CORS

- 웹 개발에서 다른 도메인으로의 요청이 필요하여 cross-domain을 요청할 수 있도록 CORS라는 것이 만들어 졌다.
- 간단히 말해서 동일한 출처가 아닌 다른 출처에서 데이터를 주고 받는 것을 허용하는 정책이다.
  - 동일한 출처란 프로토콜, 도메인주소, 포트번호가 같은 URL을 의미한다.

- CORS가 아전하게 다른 출처와 리소스를 공유하는 방법은 두가지가 있다.

### Header

- 요청들은 요청 헤더와 응답하는 헤더를 통해서 이루어진다.

- 요청 헤더
  1. Access-Control-Request-Method
    - 요청을 할 때 어떤 메서드를 사용할 것인지를 알려주는 것이다.

  2. Access-Control-Request-Headers
    - 요청을 할 때 어떤 헤더를 사용할 것인지 알려주는 것이다.

- 응답 헤더
  1. Access-Control-Allow-Origin
    - 리소스에 접근할 수 있도록 허용하는지를 알려주는 것이다.

  2. Access-Control-Expost-Headers
    - 브라우저에게 접근할 수 있는 리스트들을 알려주는 것이다.

  3. Access-Control-Max-Age
    - 캐싱되는 시간을 알려주는 것이다.

  4. Access-Control-Allow-Credentials
    - 크리덴셜이 true일 때 요청할지에 대한 것을 알려주는 것이다.

  5. Access-COntrol-Allow-Methds
    - 허용되는 메서도를 알려주는 것이다.

  6. Access-Control-Allow-Headers
   - 사용 가능한 HTTP 헤더를 알려주는 것이다.

### 요청의 두가지 방법

#### Preflight Request (예비요청)

- 예비 요청은 말 그대로 미리 요청을 보내보고, 안전한지를 판단한 뒤에 본격적으로 요청을 하는 방식이다.

- 헤더에 Access-Control-Request-Method를 통해 요청하는 HTTP 메서드 GET,POST,PUT,DELETE 중 하나의 메서드와 Access-COntrol-Request-Headers를 통해 OPTIONS라는 헤더를 넣고 요청을 보낸다.

- 해당 메서드와 헤더가 우효하다면 서버는 응답 헤더를 통해 접근 가능한지(Access-Control-Allow-Origin), 사용할 수 있는 리소스의 리스트(Access-COntrol-Expose-Headers), 캐싱되는 시간(Access-Control-Max-Age)등을 알려주는 것이다.


#### Simple Request (단순요청)

- 단순 요청은 예비 요청과는 달리 서버에 바로 본격적으로 요청을 시작한다.
- 여러 조건들을 걸고 해당 조건에 부합한다면 아전한 요청이라 인식하고 데이터를 응답하는 형식이다.
- 요청 조건
  1. Access-Control-Request-Method를 통해 요청할 때 메서드는 HTTP메서드가 아닌 GET,HEAD,POST 중 하나여야 한다.
  2. Access-Control-Request-Headers 통해 요청을 보낼때 Accept, Accept-Language, Content-Language, Content-TypeDPR, Downlink, Save Data, Viewport-Width 중 하나여야 한다.
  3. Content-Type을 사용할 경우 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나여야 한다.


## 쿠키, 세션, 웹스토리지

### 쿠키

- 클라이언트에 저장되는 키와 값이 들어있는 작은 파일
- 클라이언트의 상태 정보를 로컬에 저장했다가 참조
- 300개까지 쿠키 저장가능, 도메인당 20개의 값 가능, 하나의 쿠키는 4KB까지 가능
- Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들수 있음
- 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request 시에 Request Header를 넣어서 자동으로 서버에 전송

### 세션

- 사용자 정보를 파일 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리함
- 서버에서 클라이언트를 구분하기 위해 세션 ID를 부여하며, 웹 브라우저가 서버에 접속해서 브라우저를 조욜할 때 까지 인증상태를 유지
- 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정 가능
- 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨

### 쿠키 세션 간단 비교

- 저장 위치 : 쿠키 - 클라이언트, 세션 - 서버
- 보안 : 쿠키 < 세션
  - 쿠키는 스니핑에 당할 우려가 있지만 세션은 쿠키를 이용해 세션 아이디만 저장하고 서버에서 처리하기때문에 보안이 좋다.
- 라이프 사이클 : 쿠키는 브라우저를 종료해도 만료기간이 남아있으면 존재, 세션은 브라우저 종료시 바로 종료
- 속도 : 쿠키 > 세션

### 웹스토리지

- 클라이언트에 데이터를 저장할 수 있또록 HTML5부터 추가된 저장소
- 간단한 Key-Value 스토리지 형태
- 쿠키와 달리 자동 전송의 위험성이 없음
- 오리진(Origin : 도메인, 프로토콜, 포트)단위로 접근이 제한되는 특성 덕분에 CSRF로부터 안전
- 쿠키보다 큰 저장 용량 지원(.모바일 2.5MB, 데스크탑 5~10MB)
- 서버가 HTTP 헤더를 통해 스토리지 객체를 조작할 수 없음(웹 스토리지 객체 조작은 JavaScript 내에서만 수행)
- 오직 문자형 데이터 타입만 지원
- 로컬스토리지와 세션스토리지가 있으며 같은 Storage 객체를 상속하기 때문에 메서드가 동일

#### 로컬 스토리지(localStrocge)

- 사용자가 데이터를 지우지 않는 이상, 브라우저나 OS를 종료해도 계속 남아있음(영구성)
- 동일한 브라우저만 해당
- 지속적으로 필요한 데이터 저장(자동 로그인 등)

#### 세션 스토리지(sessionStorage)

- 데이터가 오리진 뿐만 아니라 브라우저 탭에도 종속되기 때문에, 윈도우나 브라우저 탭을 닫을 경우 제거
- 일시적으로 필요한 데이터 저장(일회성 로그인 정보, 입력폼 저장 등)


## 자바 어노테이션(Annotation)

### 어노테이션의 용도

- 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공
- 소프트웨어 개발툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공
- 실행시(런타임시)특정 기능을 실행하도록 정보를 제공

### 내장 어노테이션

- 7개의 표준 어노테이션 중 3개가 java.lang의 일부이며 나머지 4개는 java.lang.annotation으로부터 가져온다.

### 어노테이션 종류

#### 자바 코드에 적용되는 내장 어노테이션

- @Override
  
