---
laout : single
title: "Java.io 패키지"
excerpt : "자바 입출력"
categories :
- Java
tags :
- [Playdata ,Java]
toc: true #Table of contents 옆에 목록이 생성됨
toc_sticky: true #toc가 화면을 따라 내려옴
toc_label: 목차 #toc 상단에 써있는 제목

date: 2021-10-13
last_modified_at: 2021-10-13
---

자바 교육 16일차

## 자바 입출력
java.io 패키지
외부데이터를 사용하려면 연결하는 길을 생성한다고 생각하자. 데이터가 들어오거나 나가는 길을 Stram이라고 합니다. InputStream, OutputStream

~Set,List,Map은 Collection 객체라고 생각한다. java.util 패키지에 포함된다.
~Exception은 예외 정의 객체이고 java.lang 패키지에 포함된다.

~InputStream, ~OutputStream 클래스는 기본 작업 단위가 1byte이고 ~ Reader, ~ Writer 는 기본 작업 단위가 2byte 이다.
1byte는 영문자 1개

메모리에 byte[] 배열을 내보내고 싶으면 ByteArray 입출력 클래스도 있다. API문서를 보고 어떤 데이터를 받거나 내보낼지 확인하고 사용하자.
개발할때는 유지보수에 유리한 상대경로를 쓰는게 좋다.
절대 경로 = C:\Test\a.txt
상대 경로 = a.txt , test/a.txt , ../a.txt(상위 디렉토리는 ..으로), ./a.txt(현재 디렉토리)

file은 위치정보를 나타내는 포인터가 있다.
read()메소드는 파일의 끝을 만나면 -1 리턴된다.

txt파일 읽어서 화면에 표시하고 b.txt파일도 생성
stream은 길을 만든거라 계속 작업이 되고 있는상태로 봐야한다. 작업이 끝났을경우 닫아줘야한다.
```
import java.io.*;

public class Test1 {
	public static void main(String[] args) {

		try {//FileInputStream은 throws FileNotFoundException 되어있어서
			//트라이 캐치문 해주어야한다.

			FileInputStream fi = new FileInputStream("a.txt");
			FileOutputStream fo = new FileOutputStream("b.txt");
			int c = 0;

			while( (c = fi.read()) != -1){
				System.out.print((char)c);
				fo.write(c);
			}

			fi.close();
			fo.close();

		} catch (Exception e) {
			System.out.println(e);
		}
	}
}
```


java.lang에 System 클래스를 가보자. field에 in, out 설명이 있다.

키보드 -(System.in)- Java -(System.out)- 화면
System.in은 표준 입력 스트림, System.out은 표준 출력 스트림이다!

<img src="/assets/post_photo/stream.jpg" width="100%">

키보드를 통해 입력을 주고 출력할 수도 있다.
```
import java.io.*;

public class Test2 {
	public static void main(String[] args) {
		try {
			InputStream keyboard = System.in;
			PrintStream console = System.out;
			int c = 0;
			while( (c=keyboard.read())!=-1){
				console.write(c);
			}

		} catch (Exception e) {
			System.out.println(e);
		}
	}
}
```


말단 스트림 : java<---a.txt 연결 된 스트림? 무조건 필요한 것
필터 스트림 : 샤워기에 필터 다는것처럼 해도되고 안해도된다. 생성자를 보면 알 수 있다. 생성자 매개변수가 Reader 등등

한 줄 단위로 읽어들이기, 2byte씩 읽어드리기 등등 필터를 통해 기능을 추가할 수 있다.
필터 종류중 하나인 BufferdReader, BufferedInputStream를 사용해보자.

## BufferdReader
줄 단위로 입력을 한다. 여러 필터를 껴줘서 키보드 입력을 변환한다. 필터같은 경우에는 가장 안쪽에 있는 작업먼저 close 해주어야한다.
```
public class Test3 {
	public static void main(String[] args) {

		//BufferedReader는 줄단위의 작업단위를 갖는다.
		//그리고 Reader계열만 입력받는데 System.in은 안될거다
		//InputStreamReader필터를 이용해 2byte 작업단위로 업그레이드
		BufferedReader br = null;
		try {
			//BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			//밖에 선언하고 close  연결할 수 있다.
			br = new BufferedReader(new InputStreamReader(System.in));
			System.out.println("이름을 입력하세요.");
			String name = br.readLine();
			System.out.println("헬로우~"+name);

		} catch (Exception e) {
			System.out.println(e);
		} finally {
			if(br != null)
				try {
					br.close();

				} catch (Exception e2) {
					e2.printStackTrace();
				}
		}
	}
}
```

## BufferedInputStream
주고받는 데이터 경로를 시각화하면 아래와 같다.
<img src="/assets/post_photo/BufferedInputStream.jpg" width="100%">
```
import java.io.*;

public class Test4 {

	public static void main(String[] args) {
		BufferedInputStream in = null;
		ByteArrayOutputStream out = null;
		try {
			in = new BufferedInputStream(new FileInputStream("a.txt"));
			out = new ByteArrayOutputStream();

			byte[] buf = new byte[1024];
			int len=0;//글자수를 읽자

			while((len=in.read(buf)) != -1){
				out.write(buf, 0,len);
			}

			byte[] arr=out.toByteArray();
			String s = new String(arr);
			System.out.println(s);

		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				if(in!=null){
					in.close();
				}else if(out!=null){
					out.close();
				}

			} catch (Exception e2) {
				e2.printStackTrace();
			}
		}
	}
}
```

## File 객체


PrintWriter 많이 씀 - 필터stream 쓸 필요 없음
println 메소드 있음
```
import java.io.*;

public class Test5 {
	public static void main(String[] args) {
		try{
			File dir = new File("C:\\work");

			System.out.println(dir.isDirectory());//디렉토리인지 파일인지 구분할 수있는것중 하나

			File dir2 = new File("C:\\work2");
			dir2.mkdir(); // 디렉토리 만든다

			File file = new File(dir,"file1.txt");
			file.createNewFile();

			System.out.println(file.isFile());
			System.out.println(file.exists());

			if(file.exists()){
				PrintWriter out = new PrintWriter(file);
				out.println("hello java");
			}

			System.out.println(file.getName());
			System.out.println(file.getPath());
			System.out.println(file.canWrite());
			System.out.println(file.canRead());
			System.out.println("파일크기 :"+file.length());

			File subDir = new File("c:\\work\\subDir");// \\두개쓰면 \ 하나로 인식된다.
			subDir.mkdir();
			File file2 = new File(subDir,"file2.txt");
			file2.createNewFile();

			System.out.println(file2.getAbsolutePath());
			System.out.println(file2.getParent());

			File parentDir=file.getParentFile();
			String[] fileNames = parentDir.list();
			for (String item : fileNames) {
				System.out.println(item);
			}

		}catch(Exception e){
			e.printStackTrace();
		}
	}
}
```

## properties
properties파일은 key=value 형식으로 작성되어 있어야한다. 이후 Spring을 다룰 때 똑같은 내용을 다
```
import java.io.*;
import java.util.Properties;

public class Test6 {

	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("user.properties");

			//파일을 연결해준다.
			Properties user = new Properties();
			user.load(fr);

			System.out.println(user.getProperty("id"));
			System.out.println(user.getProperty("password"));
			System.out.println(user.getProperty("name"));

      car.setProperty("model", "X5");
			FileWriter fw = new FileWriter("car.properties");
			Properties car = new Properties();
			car.setProperty("engine", "2000");
			car.setProperty("fuel", "3.3");

			car.store(fw, "car information");



		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {

			} catch (Exception e2) {

        // TODO: handle exception
			}
		}
	}
}
```

처음에 헷갈린 부분 -
file을 읽을때는 FileReader 쓰고 편집할 때 BufferdReader 썼다
파일 쓸때 FileWriter 선언하고 PrintWriter를 이용해서 라인 입력?했다
PrintWriter로 선언한걸 .println으로 한라인씩 추가해줬다
